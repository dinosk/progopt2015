package petter.simplec;
import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import petter.cfg.*;
import petter.cfg.expression.types.*;
import petter.cfg.expression.*;
import petter.cfg.edges.*;
import petter.utils.Tupel;
import petter.utils.Tripel;
import petter.utils.Terminal;
import petter.utils.AnnotatableList;
import petter.utils.PostProcessVisitor;
import petter.utils.BindingCreator;

parser code {: 

	public static boolean isTypedef(List l){
		for (Object o:l){
			if (o instanceof Integer && ((Integer)o).equals(petter.simplec.sym.TYPEDEF)) return true;
		}
		return false;
	}
	public static Type typeFrom(List l){
		for (Object o:l){
			if (o instanceof Type) return (Type)o;
		}
		return null;
	}	

    petter.utils.SymbolTable sym = new petter.utils.SymbolTable();
    public int blocknestingdepth = 0;
    public Parser(Lexer lex, ComplexSymbolFactory sf) {
        super(lex,sf);
		State initstate = createState();
 		globalinits = new Tupel<>(initstate,initstate);
	try{
	    sym.newLocal("return");
	} catch (Exception e) {System.out.println("variable return could not be created");}
    }

    public Stack<Tripel<Expression,State,State>> switchStack = new Stack<>();
    public Stack<Tupel<State, State>> loopStack = new Stack<>();

    public List<Tupel<Expression, Expression>> prefix  = new LinkedList<>();
    public Hashtable<Expression, Expression> postfix  = new Hashtable<>();

    public void throwException(String s) throws Exception{
	throw new Exception(s);
    }

	public Tupel<String,Type> parambinding(XMLElement e,Type baseType){
		String name = null;
		name=(String)((XMLElement.Terminal)SyntaxTreeXPath.query("//identifier",e).get(0)).value();
		Type t = BindingCreator.extractType(e,baseType);
		return new Tupel<>(name,t);
	}

	public Tupel<String,Type> binding(XMLElement e,Type baseType){
		String name = (String)((XMLElement.Terminal)SyntaxTreeXPath.query("//identifier",e).get(0)).value();
		Type t = BindingCreator.extractType(e,baseType);
		return new Tupel<>(name,t);
	}

    public State createState(){
        State s = new State();
        s.putAnnotation("__parser_blocknestingdepth",blocknestingdepth);
        return s;
    }
    public Transition createAssignmentEdge(State start, State end, Expression lhs, Expression rhs){
        Transition result = TransitionFactory.createAssignment(start, end, lhs, rhs);
        result.putAnnotation("__parser_blocknestingdepth",blocknestingdepth);
        return result;
    }
    public Transition createNullEdge(State start, State end){
        Transition result = TransitionFactory.createNop(start, end);
        result.putAnnotation("__parser_blocknestingdepth",blocknestingdepth);
        return result;
    }
    public Transition createAssertionEdge(State start, State end, Expression ex, Operator op){
        Transition result = TransitionFactory.createGuard(start, end, ex,op);
        result.putAnnotation("__parser_blocknestingdepth",blocknestingdepth);
        return result;
    }
    public Transition createMethodCallEdge(State start, State end, petter.cfg.expression.MethodCall m){
        Transition result = TransitionFactory.createMethodCall(start, end, m);
        result.putAnnotation("__parser_blocknestingdepth",blocknestingdepth);
        return result;
    }
    public Expression obtainExpr(String i) throws Exception{
	int num = sym.getId(i); 
        Type t = sym.getType(i);
	if (num==-1) throw new Exception("Identifier "+i+" never declared");
        final Variable var;
        Expression result;
        result= var = new Variable(num, i, t);
        for (Tupel<Expression,Expression> e : prefix) {
            if (e.a.equals(var)) result =e.b;
        }
        return result;
    }

    public Tupel<State,State> generatePrePostFixes(){
        State superStart;
        State start = createState();
        superStart = start;
	Tupel<State, State> prefix = generatePreFixes();
	Tupel<State, State> postfix =generatePostFixes(true);
	mergeStates(postfix.a, prefix.b);
        return new Tupel<State, State>(prefix.a, postfix.b);

    }
  private static Type retType(Type t){ 
    if (t instanceof Function) return ((Function)t).getReturnType();
    return ((Function)(((PointerTo)t).getInner())).getReturnType();
  }
  public Tupel<State,State> generatePreFixes(){
        State superStart, start;
        superStart = start = createState();
        for(Tupel<Expression,Expression> t : prefix){
            State connect = createState();
            Transition e;
            Type tbtype = t.b.getType();
            if ((t.b instanceof petter.cfg.expression.MethodCall)&&(retType(tbtype).equals(petter.cfg.expression.types.Void.create())))   
               e = createMethodCallEdge(start, connect, (petter.cfg.expression.MethodCall)t.b);
            else  
               e = createAssignmentEdge(start, connect, t.a, t.b);
	    e.putAnnotation( "__location_left", t.b.getAnnotation("__location_left"));
	    e.putAnnotation( "__location_right", t.b.getAnnotation("__location_right"));
	    start.putAnnotation("__location", e.getAnnotation("__location_left"));
	    connect.putAnnotation("__location", e.getAnnotation("__location_right"));
	    start = connect;
	   
        }
        prefix.clear();
	return new Tupel<State, State>(superStart, start);

    }

 public Tupel<State,State> generatePostFixes(boolean clear){
        State superStart;
        State start = createState();
        superStart = start;
	for(Expression i : postfix.keySet()){
            State connect = createState();
            Transition e = createAssignmentEdge(start, connect, i, postfix.get(i));
	    e.putAnnotation( "__location_left", postfix.get(i).getAnnotation("__location_left"));
	    e.putAnnotation( "__location_right", postfix.get(i).getAnnotation("__location_right"));
	    //System.out.println("annotion of assign edge: "+e.getAnnotations());
	    start.putAnnotation("__location", e.getAnnotation("__location_left"));
	    connect.putAnnotation("__location", e.getAnnotation("__location_right"));
            start = connect;
        } 
        if (clear) postfix.clear();
        return new Tupel<State, State>(superStart, start);

    }




    public  void mergeStates(State news, State old){
	Iterator<Transition> iter = old.getInIterator();
	if(!iter.hasNext()) 
	{Transition e = createNullEdge(old, news); 
	e.putAnnotation( "__location_left", news.getAnnotation("__location"));
	e.putAnnotation( "__location_right", old.getAnnotation("__location"));
	if(old.isLoopSeparator()) news.setLoopSeparator(true);
	if(old.getAnnotation("__label") != null) news.putAnnotation("__label", old.getAnnotation("__label"));
	return; }
	
	while(iter.hasNext()){
	    Transition e = iter.next();
	    if(news.getAnnotation("__location") == null){
		news.putAnnotation("__location", old.getAnnotation("__location"));
	    }
	    if(old.getAnnotation("__location") == null){
		old.putAnnotation("__location", news.getAnnotation("__location"));
	    }
	    e.setDest(news);
        }
    }

	Tupel<State,State> globalinits;
	List<State> returns;
	public void resetReturns(){
		returns=new LinkedList<State>();
	}
	public void addReturn(State s){
		returns.add(s);
	}
	public Iterable<State> currentReturns(){
		return returns;
	}
    /** Report a fatal error.  This method takes a  message string and an 
     *  additional object (to be used by specializations implemented in 
     *  subclasses).  Here in the base class a very simple implementation 
     *  is provided which reports the error then throws an exception. 
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    @Override
    public void report_fatal_error(String message, Object   info) throws Exception {
        System.err.println("FATAL: "+message+" "+info);
        throw new Exception("in Simple C Compiler:\n  "+ message+ "\n  occured at "+info);
    }
    /** Report a non fatal error (or warning).  This method takes a message 
     *  string and an additional object (to be used by specializations 
     *  implemented in subclasses).  Here in the base class a very simple 
     *  implementation is provided which simply prints the message to 
     *  System.err. 
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    @Override
    public void report_error(String message, Object info) {
        System.err.println("ERROR: "+message+" "+info);
    }

    /** This method is called when a syntax error has been detected and recovery 
     *  is about to be invoked.  Here in the base class we just emit a 
     *  "Syntax error" error message.  
     *
     * @param cur_token the current lookahead Symbol.
     */
    @Override
    public void syntax_error(Symbol cur_token) {
      report_error("Syntax error", cur_token);
      report_expected_token_ids();
    }
    /** This method is called if it is determined that syntax error recovery 
     *  has been unsuccessful.  Here in the base class we report a fatal error. 
     *
     * @param cur_token the current lookahead Symbol.
     */
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
      report_fatal_error("Couldn't repair and continue parse", cur_token);
      //report_expected_token_ids();
    }

        :}; 

/* Terminals (tokens returned by lexer). */


terminal		 INT, VOID,CHAR,DOUBLE,FLOAT,LONG,SHORT;
terminal Terminal<Type>    TYPE_NAME;
terminal         TYPEDEF, RETURN, DO, FOR, PRAGMA, HASH, BREAK, CONTINUE, GOTO, DEFAULT, CASE, SWITCH, WHILE, IF, ELSE;
terminal         COMMA,COLON, BEGIN, END, LPAR, RPAR, LSQ, RSQ;
terminal         ADDOFOP, QUESTIONMARK, INCOP, DECOP, ADDOP, SUBOP, MULOP, DIVOP, NOT, EQ, PLUSEQ, MINUSEQ, MULEQ, DIVEQ;

terminal         OR, AND, GEQ, LEQ, NEQ, LT, GT, ASSIGN, SEMI, ILLEGAL, COMMENT;

terminal Terminal<Integer> INTCONST;
terminal Terminal<String>  IDENT;

//non terminal Type typespec;
non terminal CompilationUnit translationunit;
non terminal Tupel<List<Integer>,List<Procedure>> declarationlist;
non terminal Tupel<State, State> initdecl;
non terminal Type paramdecl;
non terminal Procedure procdecl;
non terminal Tupel<State,State> body;
non terminal Tupel<State,State> elseprod;
non terminal Tupel<State,State> statementlist;
non terminal List<Type> paramlist;
non terminal AnnotatableList<Expression> exprlist;
non terminal AnnotatableList<Tupel<State,State>> initdeclList;
non terminal Tupel<State,State> statement;
non terminal Expression expr;
non terminal Expression lhsexpression;
non terminal Tripel<State, State,State> boolex;
non terminal Type type;
non terminal List declspec;
non terminal List dspec;
non terminal Integer storageclassspec;
non terminal XMLElement declarator;
non terminal XMLElement direct_declarator;
non terminal XMLElement abstract_declarator;
non terminal XMLElement direct_abstract_declarator;
non terminal Type typename;
non terminal Integer pointer;
non terminal Expression assign_opt;

precedence right ASSIGN;
precedence right ELSE, AND, OR, MULEQ, DIVEQ, PLUSEQ, MINUSEQ, ADDOP, DIVOP, MULOP, SUBOP, LSQ;


translationunit  ::= declarationlist:l
           {:
            Hashtable<String,Procedure> ht = new Hashtable<String,Procedure>();
            for (Procedure m: l.b){
                ht.put(m.getName(),m);
            }
		parser.sym.enterBlock();
		parser.blocknestingdepth++;
		parser.resetReturns();


		State newend = parser.createState();
		int tmpid = parser.sym.newTemporary(Int.create());
    	Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),Int.create());
		parser.createAssignmentEdge(parser.globalinits.b,newend,tmp,new petter.cfg.expression.MethodCall("main",null,new LinkedList<>()));
		Procedure init = new Procedure("$init",parser.globalinits.a,newend,new LinkedList<>(),new LinkedList<>());
		ht.put(init.getName(),init);
	    
    	parser.sym.leaveBlock();
    	parser.blocknestingdepth--;

		CompilationUnit cls = new CompilationUnit(parser.sym.getGlobalSymbolTable(), ht, parser.sym.getGlobals());
	    RESULT = cls;
	    PostProcessVisitor.prettify(cls);
            for (Procedure m: cls){
                m.refreshStates();
            }
	    :}
;

dspec ::= declspec:ds {: 
	RESULT = ds; 
    parser.sym.setLastParsedType(typeFrom(ds));
    isTypedef(ds);
:}
;
declspec ::= type:typ 					{: RESULT=new LinkedList();RESULT.add(typ); :}
	| type:typ declspec:ds 				{: RESULT=ds;RESULT.add(typ); :}
	| storageclassspec:scs declspec:ds  {: RESULT=ds;RESULT.add(scs); :}
	| storageclassspec:scs 				{: RESULT=new LinkedList(); RESULT.add(scs); :}
;

storageclassspec ::= TYPEDEF {: RESULT= new Integer(petter.simplec.sym.TYPEDEF); :}
//	| EXTERN:id
//	| STATIC:id
//	| AUTO:id
//s	| REGISTER:id
;

declarationlist ::= 
declarationlist:l type:typ initdeclList:il
{:
	State begin=parser.globalinits.b;
	State end=begin;
 	for(Tupel<State, State> init : il){
        parser.mergeStates(init.a, begin);
     	begin = init.b;
     	Tupel<State,State> t = parser.generatePostFixes(true);
     	parser.mergeStates(t.a, init.b);
     	end = t.b;
 	}
	parser.globalinits = new Tupel<State, State>(parser.globalinits.a, end);
	RESULT = l;
:} 
 SEMI
 | declarationlist: l procdecl:d
{:  if (d!=null)
        l.b.add(d);
RESULT = l;
    :}
| /* empty */
{:
    RESULT = new Tupel<List<Integer>,List<Procedure>>(new ArrayList<Integer>(),new ArrayList<Procedure>());

        :}
;
pointer ::= MULOP         {: RESULT =1; :}
		| MULOP pointer:i {: RESULT= i+1; :}
;
declarator ::= pointer:p direct_declarator:dd {: RESULT = new XMLElement.NonTerminal("pointer",0,new XMLElement.Terminal(pxleft,"count",p,pxright),dd); :}
			| direct_declarator:dd  {: RESULT = dd; :}
;
abstract_declarator ::= pointer:p {: RESULT = new XMLElement.NonTerminal("pointer",0,new XMLElement.Terminal(pxleft,"count",p,pxright)); :}
	| direct_abstract_declarator:dad {: RESULT = dad; :}
	| pointer:p direct_abstract_declarator:d {: RESULT = new XMLElement.NonTerminal("pointer",0,new XMLElement.Terminal(pxleft,"count",p,pxright),d); :}
;
direct_declarator ::= IDENT:i        {: RESULT=new XMLElement.Terminal(ixleft,"identifier",i.getTerminal(),ixright); :}
	| LPAR declarator:d RPAR         {: RESULT=d; :}
	| direct_declarator:dd LSQ RSQ          {: RESULT=new XMLElement.NonTerminal("array",0,dd); :}
	| direct_declarator:dd LSQ expr:e RSQ   {: RESULT=new XMLElement.NonTerminal("array",1,dd,new XMLElement.Terminal(exleft,"index",e,exright)); :}
	| direct_declarator:dd LPAR
	{: 
	parser.sym.enterBlock();
    parser.blocknestingdepth++;
	parser.resetReturns();
	:}
	paramlist:p RPAR {: 
	parser.sym.leaveBlock();
    parser.blocknestingdepth--;
	RESULT=new XMLElement.NonTerminal("function",0,dd,new XMLElement.Terminal(pxleft,"params",p,pxright)); :}	
;
direct_abstract_declarator ::= LPAR abstract_declarator:d RPAR {: RESULT=d; :}
	| direct_abstract_declarator:dd LSQ RSQ {: RESULT=new XMLElement.NonTerminal("array",0,dd); :}
	| direct_abstract_declarator:dd LSQ expr:e RSQ {: RESULT=new XMLElement.NonTerminal("array",1,dd,new XMLElement.Terminal(exleft,"index",e,exright)); :}
	| LSQ RSQ {: RESULT=new XMLElement.NonTerminal("array",2); :}
	| LSQ expr:e RSQ {: RESULT=new XMLElement.NonTerminal("array",3); :}
	| direct_abstract_declarator:dd LPAR
	{:
    parser.sym.enterBlock();
    parser.blocknestingdepth++;
	parser.resetReturns();
	:} 
	paramlist:p RPAR {: 
    parser.sym.leaveBlock();
    parser.blocknestingdepth--;
	RESULT=new XMLElement.NonTerminal("function",0,dd,new XMLElement.Terminal(pxleft,"params",p,pxright)); :}	
	| LPAR
	{:
	parser.sym.enterBlock();
    parser.blocknestingdepth++;
	parser.resetReturns();
	:}
	paramlist:p RPAR {:     
	parser.sym.leaveBlock();
    parser.blocknestingdepth--;
	RESULT=new XMLElement.NonTerminal("function",1,new XMLElement.Terminal(pxleft,"params",p,pxright)); :}	
;

initdecl ::=  
declarator:d 
{:
	Type baseType = parser.sym.getLastParsedType();
	Tupel<String,Type> binding = parser.binding(d,baseType);
    try {
		parser.sym.setLastParsedType(binding.b);
		int id = parser.sym.newLocal(binding.a);
		Variable var = new Variable(id,binding.a,binding.b);
     	UnknownExpression u = new UnknownExpression(binding.b);
		//u.putAnnotation("__location_left", i.getAnnotation("__location_left"));
     	//u.putAnnotation("__location_right", i.getAnnotation("__location_right"));
		parser.prefix.add(Tupel.create(var, u));
     	RESULT = parser.generatePreFixes();
		parser.sym.setLastParsedType(baseType);
	}catch (Exception ex){
		ex.printStackTrace();
		parser.report_fatal_error("Identifier "+binding.a+" already declared!",binding.a);
	}
:} 
assign_opt:o {:
	if (o!=null){
		Type baseType = parser.sym.getLastParsedType();
		Tupel<String,Type> binding = parser.binding(d,baseType);
		int num = parser.sym.getId(binding.a);   
		Variable var = new Variable(num,binding.a,binding.b);
		parser.prefix.add(Tupel.create(var,o));
		RESULT=parser.generatePreFixes();
	}
:}
;
assign_opt ::= ASSIGN expr:e {:	RESULT = e; :}
|
{:
RESULT=null;
:} 
;


type ::= typename:t {: RESULT = t; 
                      parser.sym.setLastParsedType(RESULT);
                    :}
;
typename ::= VOID {: RESULT = petter.cfg.expression.types.Void.create(); :}
    | INT {: RESULT = Int.create(); :}
    | CHAR {: RESULT = Char.create(); :}
    | DOUBLE {: RESULT = petter.cfg.expression.types.Double.create(); :}
    | FLOAT {: RESULT = petter.cfg.expression.types.Float.create(); :}
    | LONG {: RESULT = petter.cfg.expression.types.Long.create(); :}
    | SHORT {: RESULT = petter.cfg.expression.types.Short.create(); :}
    | TYPE_NAME:t {: RESULT = t.getTerminal(); :}
;

///////////////////////////////////////
paramdecl ::= type:t {: RESULT = t; :}
| type:typ abstract_declarator:d 
{: Tupel<String,Type> binding = parser.parambinding(d,typ);
 RESULT=binding.b;
 :}
| type:typ declarator:d 
{: Tupel<String,Type> binding = parser.parambinding(d,typ);
 RESULT=binding.b;
 if (binding.a!=null){
 	try{
     	int id = parser.sym.newParameter(binding.a,binding.b);
 	}catch (Exception e) {
		e.printStackTrace();
     	parser.report_fatal_error("Parameter "+binding.a+" already declared", binding.a);
    }
  }
 :}
;
paramlist ::= paramlist:l COMMA paramdecl:d{:  RESULT = l; RESULT.add(d);  :} 
| paramdecl:d  {: RESULT = new LinkedList<Type>(); RESULT.add(d); :}
| /* empty */  {: RESULT = new LinkedList<Type>(); :}
;


procdecl ::= 
 type:baseType declarator:d 
{: 
	Tupel<String,Type> binding = parser.binding(d,baseType);
    try {
		parser.sym.setLastParsedType(binding.b);
	    // TODO: Check type refinement for function prototypes!!!
		if (parser.sym.getType(binding.a)==null)
        	parser.sym.newLocal(binding.a);
		parser.sym.setLastParsedType(baseType);
	}catch (Exception ex){
		ex.printStackTrace();
		parser.report_fatal_error("Identifier "+binding.a+" already declared!",binding.a);
	}
	parser.sym.undoLeave();
    parser.blocknestingdepth++;
	parser.sym.setLastParsedType(binding.b);
	if (parser.sym.getType(binding.a)==null)
        	parser.sym.newLocal(binding.a);
	parser.sym.setLastParsedType(baseType);
:} 
BEGIN statementlist:l END
{:
	Tupel<String,Type> binding = parser.binding(d,baseType);
    List<Integer> locals =  parser.sym.getLocals();
	//TODO: Parameters need to be extracted from declarator!!!!
    List<Integer> params = parser.sym.getParameters();
    List<Type> list = (List<Type>)(((Function)binding.b).parameter());
    for(Integer p : params) list.add(parser.sym.getType(p));
    State newret = parser.createState();
	parser.createNullEdge(l.b,newret);
	for (State r: parser.currentReturns()){
		parser.createNullEdge(r,newret);
	} 

    RESULT = new Procedure(binding.a,l.a,newret,locals, params); 

    parser.sym.leaveBlock();
    parser.blocknestingdepth--;
  :}
;

/////////////////////////////////////////////////
body ::= {: 
	  parser.sym.enterBlock();
          parser.blocknestingdepth++;
    :}BEGIN statementlist:l {:
          parser.sym.leaveBlock();
          parser.blocknestingdepth--;
    :}END
{:
    RESULT = l;
 :}
;


initdeclList ::= initdecl:i COMMA initdeclList:l
{: 
 l.add2Begin(i);
 RESULT = l;
:}
| initdecl:i 
{:
    AnnotatableList<Tupel<State, State>> list = new AnnotatableList();
    list.add(i);
    RESULT = list;
	:};


exprlist ::= expr:e COMMA exprlist:l
{:
 l.add2Begin(e);
 RESULT = l;
 :}

| expr : e
{:
    AnnotatableList<Expression> list = new AnnotatableList();
    list.add(e);
    RESULT = list;
	:}
;

statementlist ::= statement:t statementlist:l
{:
 parser.mergeStates(l.a, t.b);
 RESULT= new Tupel<State, State>(t.a, l.b);
:}
| 
{:
    State s = parser.createState();
    Tupel<State,State> t = new Tupel<State,State>(s,s);
    RESULT = t;
:}
;

////////////////////////////////////////////////////////statements

elseprod ::= ELSE statement:s
{: RESULT =s; :}
|
{: State s = parser.createState(); RESULT =new Tupel<State,State>(s,s); :}
;

statement ::= HASH PRAGMA IDENT:i
{:
 State middle = parser.createState(); //als Referenzknoten zum Rücksprung in CFG-View
 middle.putAnnotation("__location", i.getAnnotation("__location_left"));
 middle.putAnnotation("__label", i.getTerminal());
 RESULT = new Tupel<State, State>(middle, middle);
 :}
| type:typ  initdeclList:list
{:
 State begin = parser.createState();
 State b=list.get(0).a;   
 State end = parser.createState();
 Tupel<State, State> t;
 for(Tupel<State, State> init : list){
     parser.mergeStates(init.a, begin);
     begin = init.b;
     t = parser.generatePostFixes(true);
     parser.mergeStates(t.a, init.b);
     end = t.b;
 } 
 RESULT = new Tupel<State, State>(b, end);
:}SEMI 
| FOR LPAR expr:e1{:
    RESULT = parser.generatePrePostFixes();
 	:} SEMI boolex:b{:
    Tupel<State,State> t = parser.generatePreFixes();
    //System.out.println("Prefix of boolex: "+t);
    parser.mergeStates(t.a, RESULT.b);
    State condBegin = t.a;
    condBegin.putAnnotation("__location", t.getAnnotation("__location_left"));
    
    Transition e = parser.createNullEdge(t.b,b.a);
    e.putAnnotation( "__location_left", b.a.getAnnotation("__location_left"));
    e.putAnnotation( "__location_right", t.getAnnotation("__location_right"));
    //parser.mergeStates(b.a, t.b);
    b.a = RESULT.a;
   
	condBegin.setLoopSeparator(true);
    t = parser.generatePostFixes(false);
    parser.mergeStates(t.a, b.b);
    b.b=t.b; //succeded
    t = parser.generatePostFixes(true);
    parser.mergeStates(t.a, b.c);
    b.c=t.b; //failed
    RESULT = new Tupel<State, State>(condBegin, b.c);
    //perceive continue and break point for this loop on top of loopStack
    parser.loopStack.push(new Tupel<State, State>(b.c, b.a));
	:} SEMI expr:e2{:
    Tupel<State,State> t = parser.generatePrePostFixes();
    parser.mergeStates(RESULT.a,t.b);
    RESULT.a = t.a;

	:} RPAR statement:stmt 
{:
    // parser.blocknestingdepth--;
    parser.mergeStates(stmt.a, b.b);
    parser.mergeStates(RESULT.a, stmt.b);
    RESULT = new Tupel<State,State>(b.a, b.c);
    
    //when finished loop remove continue/break point tupel from loopStack
    parser.loopStack.pop();
	:}

|{:
    //perceive continue and break point for this loop on top of loopStack
    State endLoop = parser.createState();
    State continueLoop = parser.createState();
    parser.loopStack.push(new Tupel<State, State>(endLoop, continueLoop));
    RESULT = new Tupel<State, State>(endLoop, continueLoop);
//    parser.blocknestingdepth++;
:} DO statement:stmt WHILE LPAR boolex:b RPAR SEMI
{:
    //  parser.blocknestingdepth--;
    Transition e = parser.createNullEdge(RESULT.b, stmt.a);
    e.putAnnotation( "__location_left", stmt.a.getAnnotation("__location_left"));
    e.putAnnotation( "__location_right", RESULT.b.getAnnotation("__location_right"));
    
    b.a.setLoopSeparator(true);
    parser.mergeStates(b.a, stmt.b);
    Tupel<State,State> t = parser.generatePreFixes();
    parser.mergeStates(b.a,t.b);
    b.a=t.a;
    
    t = parser.generatePostFixes(false);
    parser.mergeStates(t.a, b.b);
    b.b=t.b; //succeded
    t = parser.generatePostFixes(true);

    parser.mergeStates(t.a, b.c);
    b.c=t.b; //failed
    
    Transition e2 = parser.createNullEdge(b.c,RESULT.a);
    e2.putAnnotation( "__location_left", b.c.getAnnotation("__location_left"));
    e2.putAnnotation( "__location_right", RESULT.a.getAnnotation("__location_right"));

    parser.mergeStates(stmt.a, b.b);
    //   RESULT = new Tupel<State,State>(stmt.a, b.c);
    RESULT = new Tupel<State,State>(RESULT.b, RESULT.a);

    //when finished loop remove continue/break point tupel from loopStack
    parser.loopStack.pop();
    :}

| WHILE LPAR boolex:b{:
    Tupel<State,State> t = parser.generatePreFixes();
    b.a.setLoopSeparator(true);
    parser.mergeStates(b.a,t.b);
    b.a=t.a;
    
    t = parser.generatePostFixes(false);
    parser.mergeStates(t.a, b.b);
    b.b=t.b; //succeded
    t = parser.generatePostFixes(true);
    parser.mergeStates(t.a, b.c);
    b.c=t.b; //failed
    //perceive continue and break point for this loop on top of loopStack
    parser.loopStack.push(new Tupel<State, State>(b.c, b.a));

 :} RPAR statement: stmt{:
    parser.mergeStates(stmt.a, b.b);
    parser.mergeStates(b.a, stmt.b);
    RESULT = new Tupel<State,State>(b.a, b.c);
    //when finished loop remove continue/break point tupel from loopStack
    parser.loopStack.pop();
 :} 
 | IF LPAR boolex:b {: 
    Tupel<State,State> t = parser.generatePreFixes();
    parser.mergeStates(b.a,t.b);
    b.a=t.a;
    
    t = parser.generatePostFixes(false);
    parser.mergeStates(t.a, b.b);
    b.b=t.b; //succeded
    t = parser.generatePostFixes(true);
    parser.mergeStates(t.a, b.c);
    b.c=t.b; //failed
    RESULT=null;


        :}RPAR  statement:stmt1 elseprod:stmt2
{:
    State cond = parser.createState();
    parser.mergeStates(stmt1.a, b.b);
    parser.mergeStates(stmt2.a, b.c);
    parser.mergeStates(cond, stmt1.b);
    parser.mergeStates(cond, stmt2.b);
    RESULT = new Tupel<State,State>(b.a, cond);
  :}

| expr:t
{:
    RESULT= parser.generatePrePostFixes();
        :}SEMI

| RETURN expr:t
{: 

    Tupel<State,State> tu = parser.generatePrePostFixes();
    State end = parser.createState();
    end.putAnnotation("__location", tu.getAnnotation("__location_left")); //TODO: check if correct location
    Transition e = parser.createAssignmentEdge(tu.b, end, new Variable(parser.sym.getId("return"),"return",null), t);
    e.putAnnotation( "__location_left", t.getAnnotation("__location_left"));
    e.putAnnotation( "__location_right", t.getAnnotation("__location_right"));
	parser.addReturn(end);
    tu.b=parser.createState();
    RESULT=tu;
	:}SEMI
	
| body:b
{: RESULT=b; :}
|BREAK{:  
    State start = parser.createState();
    State end = parser.createState();
    Tupel<State, State> stack = parser.loopStack.peek();
    Transition e = parser.createNullEdge(start, stack.a);
    e.putAnnotation( "__location_left", stack.getAnnotation("__location_left"));
    e.putAnnotation( "__location_right", start.getAnnotation("__location"));
    RESULT = new Tupel<State, State>(start, end);
	:} SEMI
	
|CONTINUE{:
    State start = parser.createState();
    State end = parser.createState();
    Tupel<State, State> stack = parser.loopStack.peek();
    Transition e = parser.createNullEdge(start, stack.b);
    e.putAnnotation( "__location_left", stack.getAnnotation("__location_right"));
    e.putAnnotation( "__location_right", start.getAnnotation("__location"));
    RESULT = new Tupel<State, State>(start, end);
	:}SEMI

| CASE INTCONST:i COLON statement:s
{:
    Expression guard = new BinaryExpression( new IntegerConstant(i.getTerminal()), new Operator(Operator.MINUS), parser.switchStack.peek().a);
    parser.createAssertionEdge(parser.switchStack.peek().b, s.a, guard, new Operator(Operator.EQ));
    State newcont = parser.createState();
    parser.createAssertionEdge(parser.switchStack.peek().b, newcont, guard, new Operator(Operator.NEQ));
    parser.switchStack.peek().b=newcont;
    RESULT=s;
:}
| DEFAULT COLON statement:s
{:
    parser.createNullEdge(parser.switchStack.peek().c,s.a);
    RESULT=s;
:}
| SWITCH LPAR expr:e  
{: 
    State start = parser.createState();
    State end = parser.createState();
    State defaul = parser.createState();
    parser.switchStack.push(Tripel.create(e,start,defaul)); 
    State cont=null;
    if (!parser.loopStack.isEmpty()) cont = parser.loopStack.peek().b;
    parser.loopStack.push(Tupel.create(end,cont));
    RESULT = Tupel.create(start,end);
:}  RPAR statement:s 
{:
	State st = parser.switchStack.peek().c;
    parser.createNullEdge(parser.switchStack.peek().b,parser.switchStack.peek().c);
	if (st.getOutDegree()==0) parser.createNullEdge(st,s.b);
    State start = parser.switchStack.pop().b;
    State breaks = parser.loopStack.pop().a;
    parser.createNullEdge(breaks, s.b);
    RESULT=Tupel.create(RESULT.a,s.b);
:}

|GOTO IDENT:i SEMI
{:
   State source = parser.createState();
    //TODO: actual goto implementation
   State dest = parser.sym.getStateForLabel(i.getTerminal());
   if (dest!=null) {
        parser.createNullEdge(source,dest);
   }
   else parser.sym.registerGoto(i.getTerminal(),source);
   RESULT=Tupel.create(source,parser.createState());
:}
| IDENT:i COLON statement:s
{:
    try{
    parser.sym.enterLabel(i.getTerminal(),s.a);
    } catch (Exception e){
        parser.report_error("Label "+i.getTerminal()+" already declarated",i);
    }
    RESULT=s;
:} 
;



lhsexpression ::= IDENT:i
    {:    
    int num = parser.sym.getId(i.getTerminal());   
    if(num == -1) parser.report_fatal_error("variable not declarated", i);
    RESULT = parser.obtainExpr(i.getTerminal());  
    :}
| MULOP expr:e
{:
    RESULT = new UnaryExpression(e,new Operator(Operator.DEREF));
:}
| expr:lhs LSQ expr:rhs RSQ
{:
    RESULT = new BinaryExpression(lhs,new Operator(Operator.ARRAY),rhs);
:}
;

////////////////////////////////expressions 

expr ::= lhsexpression:l   {:  RESULT = l;  :}
 | INTCONST: i {:  RESULT = new IntegerConstant(i.getTerminal()); :}
 | expr:l ASSIGN QUESTIONMARK{:
    UnknownExpression unknown =  new UnknownExpression(l.getType());
    parser.prefix.add(Tupel.create(l, unknown));
    RESULT = unknown;
    :}
| expr:l ASSIGN expr:ex
{:
    Type typ = l.getType();
    int tmpid = parser.sym.newTemporary(typ);
    Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),typ);
    parser.prefix.add(Tupel.create(l,ex));
    parser.prefix.add(Tupel.create(tmp,l));
    RESULT = tmp;
 :}
| ADDOFOP expr:e 
{:
    RESULT = new UnaryExpression(e,new Operator(Operator.ADDRESSOF));
:}
|SUBOP expr:e
{:
    RESULT = new BinaryExpression(e, new Operator(Operator.MUL), new IntegerConstant(-1));
    :}

|LPAR expr:e RPAR
{:
    RESULT = e;
	:}

| expr:lhs MULOP expr:rhs
{:
    RESULT = new BinaryExpression(lhs, new Operator(Operator.MUL), rhs);
    :}
| expr:lhs ADDOP expr:rhs
{:
    RESULT = new BinaryExpression(lhs, new Operator(Operator.PLUS), rhs);
    :}
| expr:lhs DIVOP expr:rhs
{:
    RESULT = new BinaryExpression(lhs, new Operator(Operator.DIV), rhs);
    :}
| expr:lhs SUBOP expr:rhs
{:
    RESULT = new BinaryExpression(lhs, new Operator(Operator.MINUS), rhs);
    :}
| IDENT:i DECOP
{:
    int num = parser.sym.getId(i.getTerminal());   
    if(num == -1) parser.report_fatal_error("variable not declarated", i);
    Type typ = parser.sym.getType(num);
    Variable v = new Variable(num,i.getTerminal(),typ);
    Expression ex = new BinaryExpression(v, new Operator(Operator.MINUS), new IntegerConstant(1));
    ex.putAnnotation("__location_left", i.getAnnotation("__location_left"));
    ex.putAnnotation("__location_right", i.getAnnotation("__location_right"));
    int tmpid = parser.sym.newTemporary(typ);
    Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),typ);
    parser.prefix.add(Tupel.create(tmp,v));
    parser.prefix.add(Tupel.create(v,ex));
    RESULT = tmp;
	:}
| IDENT:i INCOP
{:
    int num = parser.sym.getId(i.getTerminal());  
    if(num == -1) parser.report_fatal_error("variable not declarated", i);
    Type typ = parser.sym.getType(num);
    Variable v = new Variable(num,i.getTerminal(),typ);
    Expression ex = new BinaryExpression(v, new Operator(Operator.PLUS), new IntegerConstant(1));
    ex.putAnnotation("__location_left", i.getAnnotation("__location_left"));
    ex.putAnnotation("__location_right", i.getAnnotation("__location_right"));
    int tmpid = parser.sym.newTemporary(typ);
    Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),typ);
    parser.prefix.add(Tupel.create(tmp,v));
    parser.prefix.add(Tupel.create(v,ex));
    RESULT = tmp;
    :}
|  INCOP IDENT:i
{:
    
    int num = parser.sym.getId(i.getTerminal());  
    if(num == -1) parser.report_fatal_error("variable not declarated", i);
    Type typ = parser.sym.getType(num);
    Variable v = new Variable(num,i.getTerminal(),typ);
    Expression e = new BinaryExpression(v, new Operator(Operator.PLUS), new IntegerConstant(1));
    e.putAnnotation("__location_left", i.getAnnotation("__location_left"));
    e.putAnnotation("__location_right", i.getAnnotation("__location_right"));
    int tmpid = parser.sym.newTemporary(typ);
    Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),typ);
    parser.prefix.add(Tupel.create(v,e));
    parser.prefix.add(Tupel.create(tmp,v));
    RESULT = tmp;
:}

|  DECOP IDENT:i
{:
    int num = parser.sym.getId(i.getTerminal()); 
    if(num == -1) parser.report_fatal_error("variable not declarated", i);
    Type typ = parser.sym.getType(num);
    Variable v = new Variable(num,i.getTerminal(),typ);
    Expression e = new BinaryExpression(v, new Operator(Operator.MINUS), new IntegerConstant(1));
    e.putAnnotation("__location_left", i.getAnnotation("__location_left"));
    e.putAnnotation("__location_right", i.getAnnotation("__location_right"));
    int tmpid = parser.sym.newTemporary(typ);
    Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),typ);
    parser.prefix.add(Tupel.create(v,e));
    parser.prefix.add(Tupel.create(tmp,v));
    RESULT=tmp;
    :}

| IDENT:i PLUSEQ expr:lhs
{:
    int num = parser.sym.getId(i.getTerminal());  
    if(num == -1) parser.report_fatal_error("variable not declarated", i);
    Type typ = parser.sym.getType(num);
    Variable v = new Variable(num,i.getTerminal(),typ);
    Expression e = new BinaryExpression(v, new Operator(Operator.PLUS), lhs);
    e.putAnnotation("__location_left", i.getAnnotation("__location_left"));
    e.putAnnotation("__location_right", i.getAnnotation("__location_right"));
    int tmpid = parser.sym.newTemporary(typ);
    Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),typ);
    parser.prefix.add(Tupel.create(v,e));
    parser.prefix.add(Tupel.create(tmp,v));
    RESULT = tmp;
	:}

| IDENT:i MINUSEQ expr:lhs
{:
    int num = parser.sym.getId(i.getTerminal());  
    if(num == -1) parser.report_fatal_error("variable not declarated", i);
    Type typ = parser.sym.getType(num);
    Variable v = new Variable(num,i.getTerminal(),typ);
    Expression e = new BinaryExpression(v, new Operator(Operator.MINUS), lhs);
    e.putAnnotation("__location_left", i.getAnnotation("__location_left"));
    e.putAnnotation("__location_right", i.getAnnotation("__location_right"));
    int tmpid = parser.sym.newTemporary(typ);
    Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),typ);
    parser.prefix.add(Tupel.create(v,e));
    parser.prefix.add(Tupel.create(tmp,v));
    RESULT = tmp;
	:}

| IDENT:i DIVEQ expr:lhs
{:
    int num = parser.sym.getId(i.getTerminal());  
    if(num == -1) parser.report_fatal_error("variable not declarated", i);
    Type typ = parser.sym.getType(num);
    Variable v = new Variable(num,i.getTerminal(),typ);
    Expression e = new BinaryExpression(v, new Operator(Operator.DIV), lhs);
    e.putAnnotation("__location_left", i.getAnnotation("__location_left"));
    e.putAnnotation("__location_right", i.getAnnotation("__location_right"));
    int tmpid = parser.sym.newTemporary(typ);
    Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),typ);
    parser.prefix.add(Tupel.create(v,e));
    parser.prefix.add(Tupel.create(tmp,v));
    RESULT = tmp;
	:}

| IDENT:i MULEQ expr:lhs
{:
    int num = parser.sym.getId(i.getTerminal());  
    if(num == -1) parser.report_fatal_error("variable not declarated", i);
    Type typ = parser.sym.getType(num);
    Variable v = new Variable(num,i.getTerminal(),typ);
    Expression e = new BinaryExpression(v, new Operator(Operator.MUL), lhs);
    e.putAnnotation("__location_left", i.getAnnotation("__location_left"));
    e.putAnnotation("__location_right", i.getAnnotation("__location_right"));
    int tmpid = parser.sym.newTemporary(typ);
    Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),typ);
    parser.prefix.add(Tupel.create(v,e));
    parser.prefix.add(Tupel.create(tmp,v));
    RESULT = tmp;
	:}
| IDENT:rhs LPAR RPAR
{:  
    Type typ = parser.sym.getType(rhs.getTerminal());
    if (typ instanceof PointerTo) typ=((PointerTo)typ).getInner();
    if (!(typ instanceof Function)) parser.report_fatal_error("function call on non function type",rhs);
    Type rettyp = ((Function)typ).getReturnType();
    Expression e = new petter.cfg.expression.MethodCall(rhs.getTerminal(), typ, new ArrayList<Expression>());    
    int tmpid = parser.sym.newTemporary(typ);
    Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),rettyp);
    parser.prefix.add(Tupel.create(tmp,e));
    RESULT = tmp;
 :}
| IDENT:rhs LPAR exprlist:l RPAR
{:  
    Type typ = parser.sym.getType(rhs.getTerminal());
    if (typ instanceof PointerTo) typ=((PointerTo)typ).getInner();
    if (!(typ instanceof Function)) parser.report_fatal_error("function call on non function type",rhs);
    Type rettyp = ((Function)typ).getReturnType();
    Expression e = new petter.cfg.expression.MethodCall(rhs.getTerminal(), typ, l.getList());    
    int tmpid = parser.sym.newTemporary(typ);
    Variable tmp = new Variable(tmpid,parser.sym.getName(tmpid),rettyp);
    parser.prefix.add(Tupel.create(tmp,e));
    RESULT = tmp;
 :}
;


//////////////////////////////////boolean expression can be handled!!!! :-)
boolex ::=  expr:lhs NEQ expr:rhs
   {:
    State s = parser.createState();
    State succeded = parser.createState();
    State failed = parser.createState();
    Transition a1 = parser.createAssertionEdge(s, succeded,  new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.NEQ));
    a1.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a1.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));

    Transition a2 = parser.createAssertionEdge(s, failed, new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.EQ));
    RESULT = new Tripel<State, State, State>(s, succeded, failed);
    a2.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a2.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));
    :}        
| NOT boolex:rhs
{:

    State swap = rhs.c;
    rhs.c=rhs.b;
    rhs.b=swap;
    RESULT = rhs;
	:}
| LPAR boolex:ex RPAR
{:
    RESULT = ex;
	:}
|expr:lhs EQ expr:rhs
{:
    State s = parser.createState();
    State succeded = parser.createState();
    State failed = parser.createState();
    Transition a1 =parser.createAssertionEdge(s, succeded, new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.EQ));
    a1.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a1.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));

    Transition a2 = parser.createAssertionEdge(s, failed,  new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.NEQ));
    a2.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a2.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));
    RESULT = new Tripel<State, State, State>(s, succeded, failed);
	:}
|boolex:lhs OR boolex:rhs
{:
    State s = lhs.a;
    s.putAnnotation("__location", lhs.getAnnotation("__location_left")); //TODO: check if correct location
    State succeded = parser.createState();
    State failed = parser.createState();
    parser.mergeStates(succeded, lhs.b);
    parser.mergeStates(succeded, rhs.b);

    parser.mergeStates(rhs.a, lhs.c);
    parser.mergeStates(failed, rhs.c);
    RESULT = new Tripel<State, State, State>(s, succeded, failed);
	:}

|boolex:lhs AND boolex:rhs
{:
    State s = lhs.a;
    s.putAnnotation("__location", lhs.getAnnotation("__location_left")); //TODO: check if correct location
    State succeded = parser.createState();
    State failed = parser.createState();
    parser.mergeStates(rhs.a, lhs.b);
    parser.mergeStates(succeded, rhs.b);

    parser.mergeStates(failed, lhs.c);
    parser.mergeStates(failed, rhs.c);
    RESULT = new Tripel<State, State, State>(s, succeded, failed);
:}

|expr:lhs GEQ expr:rhs
{:
    State s = parser.createState();
    s.putAnnotation("__location", lhs.getAnnotation("__location_left")); //TODO: check if correct location
    State succeded = parser.createState();
    State failed = parser.createState();
    Transition a1 = parser.createAssertionEdge(s, succeded,  new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.GTQ));
    a1.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a1.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));

    Transition a2 = parser.createAssertionEdge(s, failed,  new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.LE));
    a2.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a2.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));
    RESULT = new Tripel<State, State, State>(s, succeded, failed);
	:}
|expr:lhs LEQ expr: rhs
{:
    State s = parser.createState();
    State succeded = parser.createState();
    State failed = parser.createState();
    Transition a1 = parser.createAssertionEdge(s, succeded,  new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.LEQ));
   a1.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a1.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));

    Transition a2 = parser.createAssertionEdge(s, failed,  new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.GT));
    a2.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a2.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));
    RESULT = new Tripel<State, State, State>(s, succeded, failed);
	:}
|expr:lhs LT expr:rhs
{:
    State s = parser.createState();
    State succeded = parser.createState();
    State failed = parser.createState();
    Transition a1 =parser.createAssertionEdge(s, succeded,  new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.LE));
    a1.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a1.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));

    Transition a2 = parser.createAssertionEdge(s, failed,  new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.GTQ));
    a2.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a2.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));
    RESULT = new Tripel<State, State, State>(s, succeded, failed);
	:}
|expr:lhs GT expr: rhs
{:
    State s = parser.createState();
    State succeded = parser.createState();
    State failed = parser.createState();
    Transition a1 =parser.createAssertionEdge(s, succeded, new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.GT));
    a1.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a1.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));

    Transition a2 = parser.createAssertionEdge(s, failed,  new BinaryExpression( lhs, new Operator(Operator.MINUS),  rhs), new Operator(Operator.LEQ));
    a2.putAnnotation( "__location_left", lhs.getAnnotation("__location_left"));
    a2.putAnnotation( "__location_right", rhs.getAnnotation("__location_right"));    
    RESULT = new Tripel<State, State, State>(s, succeded, failed);
	:}
;
